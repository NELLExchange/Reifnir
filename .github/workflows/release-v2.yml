name: Release

on:
  workflow_dispatch:
    inputs:
      imageTag:
        description: 'Docker image tag (default: latest for main or branch name for other branches)'
        required: false
      createRelease:
        description: 'Create a new release'
        required: false
        default: false

permissions: write-all

env:
  HOST_GATEWAY_IP: "172.17.0.1"
  REGISTRY: ghcr.io
  IMAGE_NAME: reifnir
  COMPOSE_PROJECT_NAME: nellebot
  COMPOSE_FILE_PATH_SRC: docker-prod/docker-compose.yml
  DB_NAME: nellebot
  DB_BACKUP_SCRIPT: nellebot-backup-db.sh
  DB_MIGRATION_SCRIPT: database_migration.sql

jobs:
  setup:
    runs-on: ubuntu-latest
    
    outputs:
      imageTag: ${{ steps.setup-vars.outputs.IMAGE_TAG }}
      needsSemver: ${{ steps.setup-vars.outputs.NEEDS_SEMVER }}
      repositoryOwnerLC: ${{ steps.setup-vars.outputs.REPOSITORY_OWNER_LC }}
      repositoryName: ${{ steps.setup-vars.outputs.REPOSITORY_NAME }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Set up environment variables
        id: setup-vars
        run: |
          BRANCH_NAME_DASH=$(echo "${GITHUB_REF#refs/heads/}" | tr '/' '-')
          
          # Set the image tag based on the branch name. If the branch is main, use "latest".
          # If the image tag is provided as an input, use that instead. 
          if [ -z "$IMAGE_TAG_OVERRIDE" ]; then
            if [ "$GITHUB_REF" = "refs/heads/main" ]; then
              IMAGE_TAG=latest
            else
              IMAGE_TAG="$BRANCH_NAME_DASH"
            fi
          else
            IMAGE_TAG="$IMAGE_TAG_OVERRIDE"
          fi
          echo "IMAGE_TAG=$IMAGE_TAG" >> "$GITHUB_OUTPUT"
          
          # If the image tag is "latest" or the branch name, flag it as needing semver.
          if [ "$IMAGE_TAG" = "latest" ]; then
              NEEDS_SEMVER=true
          elif [ "$IMAGE_TAG" = "$BRANCH_NAME_DASH" ]; then
              NEEDS_SEMVER=true
          fi
          echo "NEEDS_SEMVER: $NEEDS_SEMVER"
          echo "NEEDS_SEMVER=$NEEDS_SEMVER" >> "$GITHUB_OUTPUT"

          # Set the repository name to lowercase
          REPOSITORY_OWNER_LC=$(echo $REPOSITORY_OWNER | tr '[:upper:]' '[:lower:]');
          echo "REPOSITORY_OWNER_LC=$REPOSITORY_OWNER_LC" >> "$GITHUB_OUTPUT"
          
          # Extract the repository name from the repository env i.e. nelle/reifnir => reifnir
          REPOSITORY_NAME=${REPOSITORY##*/}
          echo "REPOSITORY_NAME=$REPOSITORY_NAME" >> "$GITHUB_OUTPUT"
        env:
          IMAGE_TAG_OVERRIDE: ${{ inputs.imageTag }}
          REPOSITORY_OWNER: ${{ github.repository_owner }}
          REPOSITORY: ${{ github.repository }}
  
  release:
    if: ${{ !inputs.createRelease }}
    runs-on: ubuntu-latest
    needs: setup
    
    steps:
      - name: Checkout
        uses: actions/checkout@v3
        with:
          sparse-checkout: |
            ${{ env.COMPOSE_FILE_PATH_SRC }}
          sparse-checkout-cone-mode: false
      
      # - name: Upload compose.yml
      #   uses: appleboy/scp-action@v0.1.7
      #   with:
      #     host: ${{secrets.VPS_HOST}}
      #     port: ${{secrets.VPS_PORT}}
      #     username: ${{secrets.NELLEBOT_USER}}
      #     key: ${{secrets.NELLEBOT_KEY}}
      #     passphrase: ${{secrets.NELLEBOT_PASSPHRASE}}
      #     source: ${{ env.COMPOSE_FILE_PATH_SRC }}
      #     target: "$HOME/"
      #     strip_components: 1
      #     overwrite: true
      #
      # - name: Release
      #   uses: appleboy/ssh-action@v1.0.3
      #   env:
      #     GHCR_USERNAME: ${{ github.actor }}
      #     GHCR_PASSWORD: ${{ secrets.GITHUB_TOKEN }}
      #     DB_CONNECTION_STRING: ${{secrets.DB_CONNECTION_STRING}}
      #     BOT_TOKEN: ${{secrets.BOT_TOKEN}}
      #     PROTECTOR_CERT_PASSWORD: ${{secrets.PROTECTOR_CERT_PASSWORD}}
      #   with:
      #     host: ${{secrets.VPS_HOST}}
      #     port: ${{secrets.VPS_PORT}}
      #     username: ${{secrets.NELLEBOT_USER}}
      #     key: ${{secrets.NELLEBOT_KEY}}
      #     passphrase: ${{secrets.NELLEBOT_PASSPHRASE}}
      #     debug: ${{vars.ACTIONS_RUNNER_DEBUG}}
      #     script_stop: true
      #     script: |
      #       FULL_IMAGE_NAME="$REGISTRY/$REPOSITORY_OWNER_LC/$IMAGE_NAME:$IMAGE_TAG"
      #      
      #       MIGRATIONS_CONTAINER_NAME="$COMPOSE_PROJECT_NAME-migrations"
      #      
      #       # Pull the image from the registry
      #       echo $GHCR_PASSWORD | docker login $REGISTRY -u $GHCR_USERNAME --password-stdin
      #       docker pull $FULL_IMAGE_NAME
      #      
      #       # Create a temporary container to extract the migration files
      #       docker create --name $MIGRATIONS_CONTAINER_NAME --add-host=host.docker.internal:$HOST_GATEWAY_IP $FULL_IMAGE_NAME
      #      
      #       # Extract the migration files into a temporary directory
      #       TMP_MIGRATIONS_DIR=$(mktemp -d -t "$MIGRATIONS_CONTAINER_NAME-XXXXXX")
      #       docker cp $MIGRATIONS_CONTAINER_NAME:/app/migrations/. $TMP_MIGRATIONS_DIR
      #      
      #       # Remove the temporary container
      #       docker rm $MIGRATIONS_CONTAINER_NAME
      #      
      #       # Stop the running compose project, if it exists
      #       docker compose -p $COMPOSE_PROJECT_NAME stop -t 30 || true
      #      
      #       # Copy the database backup script, if newer, to home directory and run it
      #       cp -u "$TMP_MIGRATIONS_DIR/$DB_BACKUP_SCRIPT" ~
      #       chmod +x "$HOME/$DB_BACKUP_SCRIPT"
      #       "$HOME/$DB_BACKUP_SCRIPT"
      #      
      #       # Run the database migration script
      #       psql -d $DB_NAME -q -f "$TMP_MIGRATIONS_DIR/$DB_MIGRATION_SCRIPT"
      #      
      #       # Take down the old compose project, if it exists
      #       docker compose -p $COMPOSE_PROJECT_NAME down || true
      #      
      #       # Start the new compose project
      #       docker compose -p $COMPOSE_PROJECT_NAME -f "$HOME/docker-compose.yml" up -d
      #      
      #       # Prune untagged images
      #       docker image prune -f
      #      
      #       # Remove the temporary directory
      #       rm -rf $TMP_MIGRATIONS_DIR
      #     envs: >-
      #       HOST_GATEWAY_IP,
      #       REGISTRY,
      #       REPOSITORY_OWNER_LC,
      #       IMAGE_NAME,
      #       IMAGE_TAG,
      #       COMPOSE_PROJECT_NAME,
      #       COMPOSE_FILE_PATH_SRC,
      #       DB_NAME,
      #       DB_BACKUP_SCRIPT,
      #       DB_MIGRATION_SCRIPT,
      #       GHCR_USERNAME,
      #       GHCR_PASSWORD,
      #       BOT_TOKEN,
      #       DB_CONNECTION_STRING,
      #       PROTECTOR_CERT_PASSWORD
  
  create-release:
    if: ${{ inputs.createRelease }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: read
    needs: setup
    env:
      IMAGE_TAG: ${{ needs.setup.outputs.imageTag }}
      NEEDS_SEMVER: ${{ needs.setup.outputs.needsSemver }}
      REPOSITORY_OWNER_LC: ${{ needs.setup.outputs.repositoryOwnerLC }}
      REPOSITORY_NAME: ${{ needs.setup.outputs.repositoryName }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: GitHub Packages Admin
        id: package-info
        uses: selfdocumentingcode/ghaction-package-admin-output@v1.1-beta2
        with:
          ghtoken: ${{ secrets.GITHUB_TOKEN }}
          operation: listPackageVersions
          org: ${{ github.repository_owner }}
          package_type: container
          package_name: ${{ env.REPOSITORY_NAME }}
          include: metadata.container.tags[*] ${{ env.IMAGE_TAG }}
          slice: __NONE__ 1 # get the first item only
          
          # Print the output of the package-info action
          # - name: Print package-info output
          #   run: |
          #     echo $(jq --version)
          #     echo "-----"
          #     echo "$PACKAGE_INFO"
          #     echo "-----"
          #     echo "'"${{ steps.package-info.outputs.result_json_output }}"'"
          #     echo "-----"
          #     echo "now with jq"
          #     echo "$PACKAGE_INFO" | jq .
          #     echo "-----"
          #     echo "$PACKAGE_INFO" | jq -r '.[0].metadata.container.tags | map(select(. != "${EXCLUDE_TAG}")) | .[0]'
          #     #echo "-----"
          #     #echo "${{ steps.package-info.outputs.result_json_output }}"
          #   env:
          #     PACKAGE_INFO: ${{ steps.package-info.outputs.result_json_output }}

      - name: Get container tags
        run: |
          echo "IMAGE_TAG: $IMAGE_TAG"
          echo "NEEDS_SEMVER: $NEEDS_SEMVER"
          
          TAG_LIST=$(echo "$PACKAGE_INFO" | jq -r '.[0].metadata.container.tags')
          echo "TAG_LIST: $TAG_LIST"
          
          SHA_TAG=$(echo "$PACKAGE_INFO" | jq -r '.[0].metadata.container.tags | map(select(startswith("sha"))) | .[0]')
          echo "SHA_TAG: $SHA_TAG"
          
          # Exclude "sha-" prefix from SHA_TAG
          COMMIT_SHA=${SHA_TAG#"sha-"}
          echo "COMMIT_SHA: $COMMIT_SHA"
          echo "COMMIT_SHA=$COMMIT_SHA" >> $GITHUB_ENV
          
          if [ "${NEEDS_SEMVER}" == "true" ]; then
            SEMVER_TAG=$(echo "$PACKAGE_INFO" | jq -r '.[0].metadata.container.tags | map(select((startswith("sha") | not) and . != "${IMAGE_TAG}")) | .[0]')
          else
            SEMVER_TAG=${IMAGE_TAG}
          fi
          echo "SEMVER_TAG: $SEMVER_TAG"
          echo "SEMVER_TAG=$SEMVER_TAG" >> $GITHUB_ENV
        env:
          PACKAGE_INFO: ${{ steps.package-info.outputs.result_json_output }}

      - name: Build changelog PRs
        id: build-changelog
        uses: mikepenz/release-changelog-builder-action@v5
        with:
          configuration: ./.config/changelog-builder.json
          mode: PR
          owner: ${{ github.repository_owner }}
          repo: ${{ env.REPOSITORY_NAME }}
          toTag: ${{ env.COMMIT_SHA }}
          fromTag: a8f8c09 # For testing
          failOnError: true

      # - name: Build changelog commits
      #   id: build-changelog2
      #   uses: mikepenz/release-changelog-builder-action@v5
      #   with:
      #     configuration: ./.config/changelog-builder.json
      #     mode: COMMIT
      #     owner: ${{ github.repository_owner }}
      #     repo: ${{ env.REPOSITORY_NAME }}
      #     toTag: ${{ env.COMMIT_SHA }}
      #     fromTag: a8f8c09 # For testing
      #     failOnError: true
          
      # - name: Create Release
      #   uses: mikepenz/action-gh-release@v1
      #   with:
      #     body: ${{steps.build-changelog.outputs.changelog}}
      #     draft: true
      #     tag_name: ${{ env.SEMVER_TAG }}
      #     target_commitish: ${{ env.COMMIT_SHA }}
